---
layout: post  
title: "两个系统的故事：现在软件神话"
description: ""
category: 读书笔记 - 架构之美
tags: [架构之美] 
---
{% include JB/setup %}
# 两个系统的故事：现代软件神话
---

软件系统就像一座由建筑和后面的路构成的城市。

###1. 混乱大都市

1. 代码需要花极长的时间来学习，没有显而易见的进入系统中的路径。这是个警告信息。
2. 从微观层面来说，也就是从每行程序、每个方法、每个组件来看，代码都是混乱而粗糙地垒在一起。不存在一致性、不存在风格、也没有统一的概念能够将不同部分的代码组织在一起。这是另一个警告信号。
3. 系统中的控制流让人觉得不舒服、无法预测。这又是一个警告信号。
4. 系统中有太多的“坏味道”，整个代码集散发着腐烂的气味，是在大热天里散发着刺激性气体的一个垃圾堆。这是一个清晰的警告信息。
5. 数据很好放在使用它的地方。经常引入额外的巴罗克式（过分装饰的，奇形怪状的）缓存层。目的是试图让数据停留在更方便的地方。这又是一个警告信息。
6. 人们知道他们面对的那一小部分区域，但没人了解整个系统。很自然，没有任何文档。这也是一个警告信号。

无论从哪个角度来看，这都不是一个好的“架构”，“大都市”的问题超出了设计的范畴，它涉及开发过程和企业文化。这些问题导致许多架构的腐烂。代码经过几年的“有机”生长，没有人进行过任何架构设计，而且各个部分随着时间的推移，没有经过太多思考就栓在一起的。没有人停下来为代码建立一个理智的结构。它增长、膨胀，成为绝对没有任何架构设计的系统的一个典型。代码集从来不会没有架构。这个系统知识拥有一个很糟糕的架构。

不好的公司结构和不健康的开发过程将在糟糕的软件架构中得到反映。

####1.1 后果

**不可理解**

缺乏强制的结构，导致了一个很难理解的软件系统，实际上几乎不可能被修改。新加入项目的团队成员会被复杂性惊呆。

坏的设计确实会招致在它上面叠加坏得设计，因为没有一种明智的方式可以扩展该设计。在所有能解决手上工作的工作方法之中，阻力最小的总会被采用，没有明显的办法来修复这些结构问题，所以只能减少麻烦，就会扔进去新的功能。

*注意：* 重要的是要保持软件的设计品质。坏得架构设计会招致更坏的架构设计。

**缺乏内聚**

系统的组件完全没有内聚性。每个组件本来都应该有一个定义良好得角色，但它们却包含了一堆杂乱的，不相干的功能。

功能和数据都放在可系统错误的地方。许多你认为是“核心服务”的部分却没有在系统的核心部分实现，而是由边远的模块来模拟实现。

开发团队中健康的工作关系将直接有益于软件设计。不健康的关系和个性膨胀会导致不健康的软件。

	内聚和耦合
	
	软件设计的关键品质是内聚和耦合。
	
	* 高内聚 （Strong cohesion）
	
	内聚是一个测量标准，说明相关的功能如何聚集在一起，模块内的各部分作为一个整体工作的如何。内聚性是将模块粘成一个整体的胶水。
	弱内聚性的模块是不良分解的信号。每个模块都必须具有清晰定义的角色，而不只是一堆不相关的功能。
	
	* 低耦合 （Low coupling）
	
	模块之间额联系有多种方式，有的是直接的，有的时间接的。模块可以调用其他模块中的函数，或被其他模块所调用。它可能使用其他模块提供的Web服务或设施，可以使用其他模块的数据类型，或提供某些数据让其他模块使用（可能是变量或文件）。
	好的软件设计会限制通信的线路，只提供哪些绝对需要的。这种通信线路是确定架构的一部分因素。
	

**不必要的耦合**
 
“大都市”没有清晰的分层。模块之间的依赖关系不是单向的，耦合常常是双向的。组件A会到达组件B的内部，目的是完成它得一项任务。在其他的地方，组件B又通过硬编码调用组件A。系统没有底层，也没有控制中心。它使整体式的一大块软件。

这意味着系统的各部分之间耦合非常紧密，你想启动系统骨架就不得不创建所有的组件。单个组件的任何改变都会波及其他组件，需要修改许多依赖它得组件。孤立地看代码组件没有任何意义。

*注意：* 好的设计考虑到内部组件连接的连接机制和连接数（以及连接性质）。系统的单个部分应该能够独立存在。紧耦合将导致不可测试的代码。

**代码问题**

因为没有通用的设计，也没有整体项目“风格”。所以没有人关心共同的编码标准、使用共同的库，或采用共同的惯例。组件、类和文件都没有命名惯例。甚至都没有共同的构建系统。

“大都市”最微妙而又最严重的问题是重复。由于没有清晰的设计，也不清楚功能应该处于的位置，所以轮子在整个代码集中不断重复发明。一些简单地东西，如通用的算法和数据结构，在许多的模块中重复出现，每种实现都带有自己位置的缺陷和怪异的行为特征。更大范围的关注点，如外部通信和数据缓存，也实现了很多次。

*注意：* 松散而模糊的架构将导致每个代码组件编写的不好，并且相互之间匹配的不好。它也会导致重复的代码和工作。

**代码以外的问题**
	
*开发团队*

项目的新成员被复杂性惊呆了，不能搞清楚状况。留下来的人非常努力的工作，项目压力大。

*缓慢的开发周期*

*支持工程师*

*第三方支持*

*公司的内部政治*

*注意：* 不良架构的影响仅限于代码。它会进一步影响到人、团队、过程和时间表。


**清晰的需求**

软件历史考察凸显可“混乱大都市”之所以混乱的一个重要原因：在项目开始之初，团队并不知道要构建的是什么。

####1.2 现状

很难加入新的特性，所以人们只是忙着添加更多不完善的功能、救急补丁和编造谎言。没有人在面对代码时感到愉快，项目正盘旋着向下栽。缺乏设计导致了不良的代码，从而又导致了不良的团队精神和不断变长的开发周期。这最终导致了公司严重的财务问题。

####1.3 来自“大都市”的明信片

那我们学到了什么？不良架构会产生深远的影响和严重的反弹。在“混乱大都市”中缺乏预见性和架构设计，导致了一下的问题。

* 低品质的软件和漫长的版本发布周期
* 系统没有弹性，不能够适应变更或添加新的功能。
* 无处不在的代码问题。
* 员工问题（压力大、士气低、跳槽等）。
* 大量混乱的公司内部政治
* 公司不能成功
* 许多痛苦和面对代码深夜加班。

###2 设计之城

“设计之城”软件项目表面上与“混乱大都市”非常相似。它也是采用C++写得消费音频产品，运行在linux操作系统上。但是，它得构建方式有很大不同，所以内部结构也非常不同。

Linux和C++是项目早期的决定，这项决定确定了团队成员的组成。从一开始，项目就有了清晰定义的目标：具体的首个产品和将来功能的路线图，代码集必须能够支持这些功能。这将是一个通用目标的代码集，可以适用于多种产品配置。

开发过程中采用了极限编程(XP)。

####2.1 设计之城的第一步

在设计过程的早期，我们确定了主要的功能领域（这包括核心的音频通道、内容管理和用户控制/界面）。我们考虑了它们如何在系统中适配，推出了初步的架构，包括了实现性能需求锁需要的核心线程模型。

系统中各独立部分的相对位置关系体现为传统的分层结构，如下所示：

	用户界面
	
	控制组件
	
	音频通道
	
	OS/音频编解码
	
这是一个基本的系统设计，可以随着功能模块的添加而轻松地增长。

早期也选择了项目将采用的支持库。关于一些基本关注点的决定也是这时候做出的。目的是位了确保代码能够容易而一致地增长，这些决定包括：

* 顶层文件结构
* 我们如何对事物命名
* “内部”展示的风格
* 公用的编码惯例
* 选择单元测试框架
* 支持基础设施（例如版本控制、适合的构建系统和持续集成）

####2.2 故事展开

在团队完成了初始设计之后，“设计之城”项目按照XP过程推进。设计和编码要门以结对的方式完成，要么经过仔细的复审，确保工作得正确性。

随着时间的推移，设计和代码不断的发展和成熟；随着“设计之城”的故事逐渐展开，产生了下面的结果。

**定位功能**

由于从以开始我们就有系统结构的清晰总体视图，所以新的功能单元可以一致地添加到代码集的正确功能区域。代码应该属于哪一块从来就不是问题。在扩展功能和修复问题时，我们总是很容易找到已有功能的实现代码。

*注意:* 架构有助于定位功能：添加功能、修复功能或修复缺陷。它为你提供了一个模板，让你将工作纳入到一张系统导航图中。

**一致性**

整个系统是一致的。各个层次的所有决定都是在整个设计的背景下做出的。开发者从一开始就有意为之，这样得到的所有代码都完全符合系统设计，并与编写的所有其他代码相匹配。

*注意：* 清晰的架构设计将导致一致的系统。所有决定都应该在架构设计的背景下做出。

顶层设计的好风格和优雅很自然会为较低的层带来好处。即使在最低层，代码也是统一而整洁的。清晰定义的软件设计确保了没有重复，熟悉的设计模式导出使用，熟悉的接口惯例普遍采用，没有特殊的对象生命周期或奇怪的资源管理问题。代码是在城市规划的背景之中写成的。

*注意：* 清晰的构架有助于减少功能的重复。

**架构的增长**

系统设计就像代码一样，被认为是可扩展、可重构的。开发团队的一项核心原则就是保持敏捷，没有什么是一成不变的，所以在需求时架构也可以修改。

*注意：* 软件架构不是一成不变的。需要时就就改变它。要想做到可以修改，架构就必须保持简单。牺牲简单性的修改要抵制。

**延迟设计决定**

YAGNI原则（You Aren't Going To Need It,如果你不是马上需要，就不要去做），这促使我们在早期只设计了重要的部分，将所有余下的决定推迟，直到我们对实际的需求有了更清晰的理解并知道该如何放到系统中最好时，再做出这些决定。

*注意：* 延迟设计决定，直到你必须做出这些决定为止。不要在你还不知道需求的时候就做出架构决定。不要猜测。

**保持品质**

从一开始，“设计之城”就准备好了一些品质控制过程：

* 结对编程
* 对没有结对编程的工作进行代码/设计复审
* 对每一段代码进行单元测试

这些过程确保了系统中从未加入不正确地、不适合的变更。所有不符合软件设计的内容都被拒之门外。这可能听起来有点过于严厉，但这些是开发者坚信的过程。

*注意:* 必须保持架构的皮质。只有当开发者们相信并对它负责时，才能做到这一点。

**管理技术债务**

除了这些品质管理方法之外，“设计之城”的开发相当注重实效的。随着最后期限的临近，一些不太重要的功能被砍掉，让产品能够准时推出。小的代码“瑕疵”或设计问题允许存在于代码集中，要么是为乐让功能快一点实现，要么是为了在接近发布时避免高风险的改动。

但是，与“混乱大都市”项目不同的是这些逃避职责的地方被标记为技术债务，并安排在后续的版本发布中修正。

**单元测试打造了设计**

*注意：* 你的系统应该有一组不错的自动化测试，它们让你在进行根本的架构变更时风险最小。这为你提供了工作的空间。

对你的代码进行单元测试将带来更好的软件设计，所以设计时要考虑可测试性。

**设计时间**

*注意：*  好的项目计划带来优质的设计。分配足够的时间来创建架构杰作，它们不会立即出现。

**与设计同行**

*注意：* 团队的组织方式必然对它产生的代码有影响。随着时间的推移，架构也会影响到团队协作的好坏。当团队瓦解时，代码的交互就很糟糕。当团队协作时，架构就集成得很好。

###3. 说明了什么问题

好的架构是由很多因素的结构，包括以下方面（但不限于此）：

* 确实进行了有意为之的前端设计
* 设计者的素质和经验
* 在开发过程中，保持清晰的设计观点
* 授权团队负责软件设计的整体设计，而团队也承担起这一责任。
* 不要害怕改变设计：没有什么是一成不变的。
* 让合适的人加入到团队中，包括设计者、程序员和经理，确保开发团队的规模合适。确保他们具有健康的工作关系，因为这些关系将不可避免地影响代码的结构。
* 在合适的时候做出设计决定，当你知道所有必要信息时再做出决定。延迟哪些暂时不能做出的决定。
* 好的项目管理，以及合适的最后期限。

###4. 轮到你了

对你目前的软件经验，请考虑以下简单的问题:

1. 什么是你看到过的最好的系统架构？

	* 你怎么知道它是好的？
	* 这个架构在代码集之内和之外带来了什么结果？
	* 你从中学到了什么？
	
2. 什么是你看到过得最差得系统架构？

	* 你怎么知道它是差的？
	* 这个架构在代码集之内和之外带来了什么结果？
	* 你从中学到了什么？

